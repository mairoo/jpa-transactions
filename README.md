# 목표

- Spring Data JPA 이용한 동시성 문제 해결 이해
  - 트랜잭션 무결성
  - 멱등성
  - 테스트를 통한 JPA 검증 (spring-boot-starter-web 의존성 없음)

- 예제 테이블
  - 잔액: Balance(id, balance)
  - 거래: Transaction(id, amount)
  - 동시성 문제와 fk 문제는 다르므로 여기서 fk 설정은 없다.

# 주요 동시성 문제 해결 기법 세 가지
- 비관적 락
  - DB 레벨 락 사용: `SELECT FOR UPDATE` 구문
- 낙관적 락
  - 애플리케이션 레벨: JPA 지원 `@Version` 애노테이션
- 유니크 제약 조건
  - DB 레벨 제약 조건 사용: `uniq` 인덱스

주요 개념
- 실제 DB에 락을 거는 것은 비관적 락과 네임드 락이다. 나머지는 락 이름이 있지만 진짜 DB 락이 아니다.
- 락이란 내가 잔액 테이블을 읽고 나서 쓰기 작업을 마칠 때까지 다른 데서 접근할 수 없도록 한다.

## 낙관적 락과 유니크 제약 조건 개념 차이
- 낙관적 락: 트랜잭션 커밋 시점에 JPA 관리 `@Version` 필드로 충돌 확인
  - JPA가 버전 관리를 자동으로 수행
  - 수정 시 버전 체크와 증가를 자동으로 처리
  - 충돌 감지 시 `OptimisticLockException` 발생

- 유니크 제약 조건: 트랜잭션 커밋 시점에 개발자 관리 `Uniq` 필드로 충돌 확인
  - 개발자가 직접 유니크한 값을 생성하고 관리
  - DB의 유니크 제약조건을 활용
  - 충돌 시 `DataIntegrityViolationException` 발생
  - 
## 락과 유니크 제약 조건의 개념 차이
- 비관적 락 or 낙관적 락: **잔액 갱신 후 거래 추가**
  - 계좌 잔액의 동시성이 핵심
  - 락 획득 즉시 잔액 갱신
  - 락 보호 하에 거래 기록
- 유니크 제약 조건: **거래 추가 후 잔액 갱신**
  - 거래의 유일성이 핵심
  - 거래 기록 성공 확인
  - 그 후 잔액 갱신

# 멱등성 보장 키 생성 전략
멱등성 보장 정의
- 멱등성(Idempotency)은 동일한 요청을 여러 번 수행하더라도 결과가 달라지지 않는 성질

멱등성의 중요성
- 네트워크 불안정성 대응
  - 클라이언트 타임아웃
  - 응답 유실
  - 네트워크 단절

멱등성 보장 키의 특징
- 글로벌 유니크해야 함
- 예측 불가능해야 함
- 시간 순서 추적 가능하면 좋음
- 적절한 길이 제한 필요

**멱등성 보장 키와 동시성 제어 필드는 용도가 다르다.**

`@Version`으로 멱등성 구현 시도 시 문제점
- 재시도 시 `OptimisticLockException` 예외 발생
- 클라이언트 상태 추적 불가
- 실패한 요청과 새 요청 구분 불가

비즈니스 키로 멱등성 구현 시도 시 문제점
- 같은 주문에 대한 여러 시도 구분 불가
- 취소/재시도 시나리오 처리 어려움
 